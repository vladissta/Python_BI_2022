# -*- coding: utf-8 -*-
"""HW_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qt8Vlqw9WMskDWzHZiz_kEst8J7xFlkz

# Задание 1 (5 баллов)

Напишите классы **Chat**, **Message** и **User**. Они должны соответствовать следующим требованиям:

**Chat**:
+ Должен иметь атрибут `chat_history`, где будут храниться все сообщения (`Message`) в обратном хронологическом порядке (сначала новые, затем старые)
+ Должен иметь метод `show_last_message`, выводящий на экран информацию о последнем сообщении
+ Должен иметь метод `get_history_from_time_period`, который принимает два опциональных аргумента (даты с которой и по какую мы ищем сообщения и выдаём их). Метод также должен возвращать объект типа `Chat`
+ Должен иметь метод `show_chat`, выводящий на экран все сообщения (каждое сообщение в таком же виде как и `show_last_message`, но с разделителем между ними)
+ Должен иметь метод `recieve`, который будет принимать сообщение и добавлять его в чат

**Message**:
+ Должен иметь три обязательных атрибута
    + `text` - текст сообщения
    + `datetime` - дата и время сообщения (встроенный модуль datetime вам в помощь). Важно! Это должна быть не дата создания сообщения, а дата его попадания в чат! 
    + `user` - информация о пользователе, который оставил сообщение (какой тип данных использовать здесь, разберётесь сами)
+ Должен иметь метод `show`, который печатает или возвращает информацию о сообщении с необходимой информацией (дата, время, юзер, текст)
+ Должен иметь метод `send`, который будет отправлять сообщение в чат

**User**:
+ Класс с информацией о юзере, наполнение для этого класса придумайте сами

Напишите несколько примеров использования кода, которое показывает взаимодействие между объектами.

В тексте задания намерено не указано, какие аргументы должны принимать методы, пускай вам в этом поможет здравый смысл)

В этом задании не стоит флексить всякими продвинутыми штуками, для этого есть последующие

В этом задании можно использовать только модуль `datetime`
"""

from datetime import datetime, timedelta, date


class Chat:
    def __init__(self, chat_history=[]):
        self.chat_history = chat_history

    def show_last_message(self):
        print(self.chat_history[0])

    def get_history_from_time_period(self, datetime_start, datetime_end):
        datetime_1 = datetime.strptime(datetime_start, "%H:%M %d-%m-%Y")
        datetime_2 = datetime.strptime(datetime_end, "%H:%M %d-%m-%Y")

        chat_history_between_dates = [m for m in self.chat_history \
                                      if datetime.strptime(m.datetime, "%H:%M %d-%m-%Y") >= datetime_1 and \
                                      datetime.strptime(m.datetime, "%H:%M %d-%m-%Y") <= datetime_2]

        return Chat(chat_history_between_dates)

    def show_chat(self):
        for message in self.chat_history[::-1]:
            message.show()
            print()

    def recieve(self, message):
        self.chat_history.insert(0, message)


class Message:
    def __init__(self, text, user):
        self.text = text
        self.datetime = None
        self.user = user

    def show(self):
        print(self.user.show_name() + ' ' + str(self.datetime) + '\n' + str(self.text))

    def send(self, chat):
        self.datetime = datetime.now().strftime("%H:%M %d-%m-%Y")
        chat.recieve(self)


class User:

    def __init__(self, username, ispremium=False):
        self.username = username
        self.ispremium = ispremium

    def show_name(self):
        if self.ispremium:
            return self.username + ' [PREMIUM]'
        return self.username


vlad = User('Vlad', True)
chatGPT = User('ChatGPT')

chat = Chat()

mess_from_vlad = Message('Hello', vlad).send(chat)
mess_from_chat = Message('How can i help you?', chatGPT).send(chat)

mess_from_vlad = Message('Hello again', vlad).send(chat)
mess_from_chat = Message('How can i help you again?', chatGPT).send(chat)

chat.show_chat()

chat.get_history_from_time_period('10:00 15-02-2023', '10:20 15-02-2023').show_chat()

"""# Задание 2 (3 балла)

В питоне как-то слишком типично и неинтересно происходят вызовы функций. Напишите класс `Args`, который будет хранить в себе аргументы, а функции можно будет вызывать при помощи следующего синтаксиса.

Использовать любые модули **нельзя**, да и вряд-ли это как-то поможет)
"""


class Args:

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

    def __rlshift__(self, other):
        return other(*self.args, **self.kwargs)


sum << Args([1, 2])

(lambda a, b, c: a ** 2 + b + c) << Args(1, 2, c=50)

"""# Задание 3 (5 баллов)

Сделайте класс наследник `float`. Он должен вести себя как `float`, но также должен обладать некоторыми особенностями:
+ При получении атрибутов формата `<действие>_<число>` мы получаем результат такого действия над нашим числом
+ Создавать данные атрибуты в явном виде, очевидно, не стоит

Подсказка: если в процессе гуглёжки, вы выйдете на такую тему как **"Дескрипторы", то это НЕ то, что вам сейчас нужно**

Примеры использования ниже
"""


class StrangeFloat(float):

    def __getattribute__(self, name):
        if '__' not in name:
            action, number = name.split('_')
            if action == 'add':
                return type(self)(self + float(number))
            elif action == 'subtract':
                return type(self)(self - float(number))
            elif action == 'multiply':
                return type(self)(self * float(number))
            elif action == 'divide':
                return type(self)(self / float(number))
            else:
                raise AttributeError


num = StrangeFloat(3.5)

num.add_1

num.subtract_20

num.multiply_5

num.divide_25

num.add_1.add_2.multiply_6.divide_8.subtract_9

getattr(num, "add_-2.5")  # Используем getattr, так как не можем написать number.add_-2.5 - это SyntaxError

"""# Задание 4 (3 балла)

В данном задании мы немного отдохнём и повеселимся. От вас требуется заменить в данном коде максимально возможное количество синтаксических конструкций на вызовы dunder методов, dunder атрибутов и dunder переменных.

Маленькая заметка: полностью всё заменить невозможно. Например, `function()` можно записать как `function.__call__()`, но при этом мы всё ещё не избавляемся от скобочек, так что можно делать так до бесконечности `function.__call__.__call__.__call__.__call__.....__call__()` и при всём при этом мы ещё не избавляемся от `.` для доступа к атрибутам. В общем, замените всё, что получится, не закапываясь в повторы, как в приведённом примере. Чем больше разных методов вы найдёте и используете, тем лучше и тем выше будет балл

Код по итогу дожен работать и печатать число **4420.0**, как в примере. Структуру кода менять нельзя, просто изменяем конструкции на синонимичные

И ещё маленькая подсказка. Заменить здесь можно всё кроме:
+ Конструкции `for ... in ...`:
+ Синтаксиса создания лямбда функции
+ Оператора присваивания `=`
+ Конструкции `if-else`
"""

import numpy as np

matrix = []
for idx in range(0, 100, 10):
    matrix += [list(range(idx, idx + 10))]

selected_columns_indices = list(filter(lambda x: x in range(1, 5, 2), range(len(matrix))))
selected_columns = map(lambda x: [x[col] for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr[:, 1] % 3 == 0
new_arr = arr[mask]

product = new_arr @ new_arr.T

if (product[0] < 1000).all() and (product[2] > 1000).any():
    print(product.mean())

import numpy as np

matrix = list.__call__()

for idx in range(0, 100, 10).__iter__():
    matrix.__iadd__([list.__call__(range(idx, idx.__add__(10)).__iter__())])

selected_columns_indices = list.__call__(
    filter(lambda x: x in range(1, 5, 2).__iter__(), range(matrix.__len__()).__iter__()))
selected_columns = map(lambda x: list.__call__(x.__getitem__(col) for col in selected_columns_indices), matrix)

arr = np.array(list.__call__(selected_columns))

mask = arr[:, 1].__mod__(3).__eq__(0)

new_arr = arr.__getitem__(mask)

product = new_arr.__matmul__(new_arr.T)

if (product.__getitem__(0).__lt__(1000)).all().__and__((product.__getitem__(2).__gt__(1000)).any()):
    print(product.mean().__str__())

"""# Задание 5 (10 баллов)

Напишите абстрактный класс `BiologicalSequence`, который задаёт следующий интерфейс:
+ Работа с функцией `len`
+ Возможность получать элементы по индексу и делать срезы последовательности (аналогично строкам)
+ Вывод на печать в удобном виде и возможность конвертации в строку
+ Возможность проверить алфавит последовательности на корректность

Напишите класс `NucleicAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Данный класс имеет новый метод `complement`, возвращающий комплементарную последовательность
+ Данный класс имеет новый метод `gc_content`, возвращающий GC-состав (без разницы, в процентах или в долях)

Напишите классы наследники `NucleicAcidSequence`: `DNASequence` и `RNASequence`
+ `DNASequence` должен иметь метод `transcribe`, возвращающий транскрибированную РНК-последовательность
+ Данные классы не должны иметь <ins>публичных методов</ins> `complement` и метода для проверки алфавита, так как они уже должны быть реализованы в `NucleicAcidSequence`.

Напишите класс `AminoAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Добавьте этому классу один любой метод, подходящий по смыслу к аминокислотной последовательности. Например, метод для нахождения изоэлектрической точки, молекулярного веса и т.д.

Комментарий по поводу метода `NucleicAcidSequence.complement`, так как я хочу, чтобы вы сделали его опредедённым образом:

При вызове `dna.complement()` или условного `dna.check_alphabet()` должны будут вызываться соответствующие методы из `NucleicAcidSequence`. При этом, данный метод должен обладать свойством полиморфизма, иначе говоря, внутри `complement` не надо делать условия а-ля `if seuqence_type == "DNA": return self.complement_dna()`, это крайне не гибко. Данный метод должен опираться на какой-то общий интерфейс между ДНК и РНК. Создание экземпляров `NucleicAcidSequence` не подразумевается, поэтому код `NucleicAcidSequence("ATGC").complement()` не обязан работать, а в идеале должен кидать исключение `NotImplementedError` при вызове от экземпляра `NucleicAcidSequence`

Вся сложность задания в том, чтобы правильно организовать код. Если у вас есть повторяющийся код в сестринских классах или родительском и дочернем, значит вы что-то делаете не так.


Маленькое замечание: По-хорошему, между классом `BiologicalSequence` и классами `NucleicAcidSequence` и `AminoAcidSequence`, ещё должен быть класс-прослойка, частично реализующий интерфейс `BiologicalSequence`, но его писать не обязательно, так как задание и так довольно большое (правда из-за этого у вас неминуемо возникнет повторяющийся код в классах `NucleicAcidSequence` и `AminoAcidSequence`)
"""

from abc import ABC, abstractmethod


class BiologicalSequence(ABC):

    def __init__(self, seq):
        self.seq = seq

    def __len__(self):
        return len(self.seq)

    def __getitem__(self, slc):
        return self.seq[slc]

    def alpha_check(self):
        if not self.seq.isalpha():
            raise SyntaxError('Please check input sequence. It should not contain any numbers and spaces')


class NucleicAcidSequence(BiologicalSequence):

    def alpha_check(self):

        if type(self) == NucleicAcidSequence:
            raise NotImplementedError('This method was not implemeted for this class')

        super().alpha_check()
        if not set(self.seq.lower()).issubset({self._nucleotides}):
            raise SyntaxError(f'Please check input sequence. It should be one of {self._nucleotides}')
        return True

    def complement(self):

        if type(self) == NucleicAcidSequence:
            raise NotImplementedError('This method was not implemeted for this class')

        str_for_dict = self._nucleotides.lower() + self._nucleotides.upper()
        _str_compl_dict = self._nucleotides[1] + self._nucleotides[0] + \
                          self._nucleotides[3] + self._nucleotides[2]
        str_compl_dict = _str_compl_dict.lower() + _str_compl_dict.upper()

        dict_compl = str.maketrans(str_for_dict, str_compl_dict)
        return self.seq.translate(dict_compl)

    def gc_content(self):
        return (self.seq.lower().count('g') +
                self.seq.lower().count('c')) / len(self)


class DNASequence(NucleicAcidSequence):
    _nucleotides = 'ATGC'

    def transcribe(self):
        dict_transcr = str.maketrans('atgcATGC', 'augcAUGC')
        return self.seq.translate(dict_transcr)


class RNASequence(NucleicAcidSequence):
    _nucleotides = 'AUGC'


class AminoAcidSequence(BiologicalSequence):
    __aa_mass = {'A': 71, 'G': 57, 'M': 131, 'S': 87,
                 'C': 103, 'H': 137, 'N': 114, 'T': 101,
                 'D': 115, 'I': 113, 'P': 97, 'V': 99,
                 'E': 129, 'K': 128, 'Q': 128, 'W': 186,
                 'F': 147, 'L': 113, 'R': 156, 'Y': 163
                 }

    def calcultae_mass(self):
        return sum(self.__aa_mass[x] for x in self.seq.upper()) - (len(self) - 1) * 19


DNASequence('aAAaauuuuUgc').alpha_check()

seque = DNASequence('aAAaaGgtTgc')

seque.complement()

NucleicAcidSequence('agagagcgcg').complement()

"""### Insulin precursor sequnce"""

prot = AminoAcidSequence(
    'mskfllqshsanaclltllltlasnldislanfehscngymrphprglcgedlhviisnlcsslggnrrflakymvkrdtenvndklrgillnkkeafsyltkreasgsitceccfnqcrifelaqycrlpdhffsrisrtgrsnsghaqlednfs')

prot.calcultae_mass()

"""True value is ~14300"""
